# AssetRipper çº¹ç†è§£ç é”™è¯¯ä¿®å¤è¯´æ˜

## ğŸ“‹ ä¿®å¤æ—¥æœŸ
2026-01-22

---

## ğŸ› é—®é¢˜æè¿°

åœ¨å¯¼å‡ºæŸäº› Unity WebGL æ¸¸æˆï¼ˆå¦‚ xiaozhenï¼‰æ—¶ï¼ŒAssetRipper ä¼šé‡åˆ°ä¸¤ä¸ªå…³é”®é”™è¯¯ï¼š

### é”™è¯¯ 1: BuildSettings è¯»å–é”™è¯¯
```
Error during reading of asset type BuildSettings. V: 2022.3.62f2
ArgumentOutOfRangeException: Specified argument was out of the range of valid values. (Parameter 'length')
```

**åŸå› **: Unity 2022.3.62f2 ç‰ˆæœ¬çš„ BuildSettings æ ¼å¼ä¸ AssetRipper æœŸæœ›çš„ä¸åŒï¼Œå¯¼è‡´æ•°ç»„è¯»å–æ—¶é•¿åº¦å‚æ•°è¶…å‡ºèŒƒå›´ã€‚

**å½±å“**: æ­¤é”™è¯¯ä¸ä¼šä¸­æ–­å¯¼å‡ºï¼Œä½†ä¼šå¯¼è‡´ BuildSettings èµ„äº§æ— æ³•æ­£ç¡®è§£æã€‚

### é”™è¯¯ 2: çº¹ç†è§£ç é”™è¯¯ï¼ˆä¸¥é‡ï¼‰
```
[Error] : System.ArgumentException: input has length 1 which is less than the required length 1048576 (Parameter 'input')
at AssetRipper.TextureDecoder.Etc.EtcDecoder.DecompressETC
```

**åŸå› **: 
1. çº¹ç†æ•°æ®æŸåæˆ–è¯»å–é”™è¯¯ï¼ˆå¦‚ "Splash Screen Unity Logo" åªæœ‰ 1 å­—èŠ‚æ•°æ®ï¼‰
2. `TextureConverter.cs` ç¬¬ 299 è¡Œä½¿ç”¨äº† `int.Max` è€Œä¸æ˜¯ `int.Min`ï¼Œå¯¼è‡´å°è¯•è¯»å–è¶…å‡ºèŒƒå›´çš„æ•°æ®
3. ç¼ºå°‘å¯¹æŸåçº¹ç†çš„æ—©æœŸæ£€æµ‹
4. ç¼ºå°‘å¯¹è§£ç å™¨å¼‚å¸¸çš„æ•è·

**å½±å“**: å¯¼è‡´æ•´ä¸ªå¯¼å‡ºè¿‡ç¨‹ä¸­æ–­å¤±è´¥ã€‚

---

## ğŸ”§ ä¿®å¤å†…å®¹

### 1. ä¿®å¤ TextureConverter.cs çš„é€»è¾‘é”™è¯¯

**æ–‡ä»¶**: `AssetRipper/Source/AssetRipper.Export.Modules.Textures/TextureConverter.cs`

#### ä¿®å¤ 1.1: ä¿®æ­£æ•°æ®åˆ‡ç‰‡é€»è¾‘ï¼ˆç¬¬ 294-311 è¡Œï¼‰

**åŸä»£ç **:
```csharp
ReadOnlySpan<byte> inputSpan = uncompressedSpan.Slice(inputOffset, int.Max(uncompressedSpan.Length - inputOffset, bytesPerLayer));
```

**é—®é¢˜**: ä½¿ç”¨ `int.Max` ä¼šé€‰æ‹©è¾ƒå¤§çš„å€¼ï¼Œå½“å‰©ä½™æ•°æ®å¾ˆå°ï¼ˆå¦‚ 1 å­—èŠ‚ï¼‰è€Œ `bytesPerLayer` å¾ˆå¤§ï¼ˆå¦‚ 1MBï¼‰æ—¶ï¼Œä¼šå¯¼è‡´ `Slice` è¶…å‡ºèŒƒå›´ã€‚

**ä¿®å¤å**:
```csharp
// è®¡ç®—å‰©ä½™æ•°æ®å¤§å°
int remainingBytes = uncompressedSpan.Length - inputOffset;
if (remainingBytes <= 0)
{
    Logger.Log(LogType.Error, LogCategory.Export, $"Not enough image data for layer {i}. Width: {width}, Height: {height}, Depth: {depth}, Format: {textureFormat}.");
    bitmap = DirectBitmap.Empty;
    return false;
}

// ä½¿ç”¨ Min è€Œä¸æ˜¯ Max æ¥é¿å…è¯»å–è¶…å‡ºèŒƒå›´
int sliceSize = bytesPerLayer > 0 ? int.Min(remainingBytes, bytesPerLayer) : remainingBytes;
ReadOnlySpan<byte> inputSpan = uncompressedSpan.Slice(inputOffset, sliceSize);
```

#### ä¿®å¤ 1.2: æ·»åŠ è§£ç å™¨å¼‚å¸¸æ•è·ï¼ˆç¬¬ 302-318 è¡Œï¼‰

**åŸä»£ç **:
```csharp
int bytesRead = DecodeTexture<TColor, TChannelValue>(textureFormat, width, height, inputSpan, outputSpan);
if (bytesRead < 0)
{
    bitmap = DirectBitmap.Empty;
    return false;
}
```

**ä¿®å¤å**:
```csharp
int bytesRead;
try
{
    bytesRead = DecodeTexture<TColor, TChannelValue>(textureFormat, width, height, inputSpan, outputSpan);
}
catch (Exception ex)
{
    Logger.Log(LogType.Error, LogCategory.Export, 
        $"Failed to decode texture layer {i}. Width: {width}, Height: {height}, Depth: {depth}, " +
        $"Format: {textureFormat}, Input size: {inputSpan.Length}, Output size: {outputSpan.Length}. " +
        $"Error: {ex.Message}");
    bitmap = DirectBitmap.Empty;
    return false;
}

if (bytesRead < 0)
{
    bitmap = DirectBitmap.Empty;
    return false;
}
```

#### ä¿®å¤ 1.3: æ·»åŠ æŸåçº¹ç†æ—©æœŸæ£€æµ‹ï¼ˆç¬¬ 150-170 è¡Œï¼‰

**ä¿®å¤å**:
```csharp
public static bool TryConvertToBitmap(ITexture2D texture, out DirectBitmap bitmap)
{
    byte[] buffer = texture.GetImageData();
    if (buffer.Length == 0)
    {
        bitmap = DirectBitmap.Empty;
        return false;
    }

    // æ£€æµ‹æ˜æ˜¾æŸåçš„çº¹ç†æ•°æ®
    // ä»»ä½•çº¹ç†å¦‚æœå°äº 64 å­—èŠ‚éƒ½å¯èƒ½æ˜¯æŸåçš„ï¼ˆå³ä½¿æ˜¯ 1x1 çš„çº¹ç†é€šå¸¸ä¹Ÿæœ‰æ›´å¤šæ•°æ®ï¼‰
    // æˆ–è€…å¦‚æœæ•°æ®å¤§å°è¿œå°äºé¢„æœŸå°ºå¯¸ï¼ˆä½¿ç”¨éå¸¸ä¿å®ˆçš„ä¼°è®¡ï¼š1 bit per pixelï¼‰
    int conservativeMinSize = int.Max(64, texture.Width_C28 * texture.Height_C28 / 8);
    
    if (buffer.Length < conservativeMinSize && buffer.Length <= 64)
    {
        Logger.Log(LogType.Warning, LogCategory.Export, 
            $"Texture '{texture.Name}' has suspiciously small data size ({buffer.Length} bytes) for dimensions {texture.Width_C28}x{texture.Height_C28}. " +
            $"Format: {texture.Format_C28E}. Skipping export to prevent decoder errors.");
        bitmap = DirectBitmap.Empty;
        return false;
    }

    // ... ç»§ç»­æ­£å¸¸è½¬æ¢ ...
}
```

### 2. ä¿®å¤ TextureAssetExporter.cs çš„å¼‚å¸¸å¤„ç†

**æ–‡ä»¶**: `AssetRipper/Source/AssetRipper.Export.UnityProjects/Textures/TextureAssetExporter.cs`

#### ä¿®å¤ 2.1: æ·»åŠ é¡¶å±‚å¼‚å¸¸æ•è·ï¼ˆç¬¬ 38-58 è¡Œï¼‰

**åŸä»£ç **:
```csharp
public override bool Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem)
{
    ITexture2D texture = (ITexture2D)asset;
    if (!texture.CheckAssetIntegrity())
    {
        Logger.Log(LogType.Warning, LogCategory.Export, $"Can't export '{texture.Name}' because resources file '{texture.StreamData_C28?.Path}' hasn't been found");
        return false;
    }

    if (TextureConverter.TryConvertToBitmap(texture, out DirectBitmap bitmap))
    {
        using Stream stream = fileSystem.File.Create(path);
        bitmap.Save(stream, ImageExportFormat);
        return true;
    }
    else
    {
        Logger.Log(LogType.Warning, LogCategory.Export, $"Unable to convert '{texture.Name}' to bitmap");
        return false;
    }
}
```

**ä¿®å¤å**:
```csharp
public override bool Export(IExportContainer container, IUnityObjectBase asset, string path, FileSystem fileSystem)
{
    ITexture2D texture = (ITexture2D)asset;
    if (!texture.CheckAssetIntegrity())
    {
        Logger.Log(LogType.Warning, LogCategory.Export, $"Can't export '{texture.Name}' because resources file '{texture.StreamData_C28?.Path}' hasn't been found");
        return false;
    }

    try
    {
        if (TextureConverter.TryConvertToBitmap(texture, out DirectBitmap bitmap))
        {
            using Stream stream = fileSystem.File.Create(path);
            bitmap.Save(stream, ImageExportFormat);
            return true;
        }
        else
        {
            Logger.Log(LogType.Warning, LogCategory.Export, $"Unable to convert '{texture.Name}' to bitmap");
            return false;
        }
    }
    catch (Exception ex)
    {
        Logger.Log(LogType.Error, LogCategory.Export, 
            $"Exception while exporting texture '{texture.Name}' ({texture.Width_C28}x{texture.Height_C28}, {texture.Format_C28E}): {ex.Message}");
        return false;
    }
}
```

---

## âœ… ä¿®å¤æ•ˆæœ

### 1. BuildSettings é”™è¯¯
- **çŠ¶æ€**: å·²è®°å½•ä½†ä¸å½±å“å¯¼å‡º
- **å¤„ç†**: é”™è¯¯ä¼šè¢«æ•è·å¹¶è®°å½•åˆ°æ—¥å¿—ï¼Œä½†ä¸ä¼šä¸­æ–­å¯¼å‡ºè¿‡ç¨‹

### 2. çº¹ç†è§£ç é”™è¯¯
- **çŠ¶æ€**: å®Œå…¨ä¿®å¤
- **æ•ˆæœ**:
  1. âœ… æŸåçš„çº¹ç†ä¼šè¢«æ—©æœŸæ£€æµ‹å¹¶è·³è¿‡
  2. âœ… è§£ç å™¨å¼‚å¸¸ä¼šè¢«æ•è·ï¼Œä¸ä¼šä¸­æ–­æ•´ä¸ªå¯¼å‡º
  3. âœ… è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯ä¼šè®°å½•åˆ°æ—¥å¿—
  4. âœ… å¯¼å‡ºè¿‡ç¨‹å¯ä»¥ç»§ç»­ï¼Œåªæ˜¯è·³è¿‡æŸåçš„çº¹ç†

---

## ğŸ“Š æµ‹è¯•ç»“æœ

### æµ‹è¯•ç”¨ä¾‹: xiaozhen WebGL æ¸¸æˆ

**ä¹‹å‰**:
```
å¯¼å‡ºè¿›åº¦: (10/223) Exporting 'Splash Screen Unity Logo'
[Error] : System.ArgumentException: input has length 1 which is less than the required length 1048576
å¯¼å‡ºå¤±è´¥ï¼Œä¸­æ–­
```

**ä¹‹å**:
```
å¯¼å‡ºè¿›åº¦: (10/223) Exporting 'Splash Screen Unity Logo'
[Warning] : Texture 'Splash Screen Unity Logo' has suspiciously small data size (1 bytes) for dimensions 1024x1024. Format: ETC_RGB4. Skipping export to prevent decoder errors.
[Warning] : Unable to convert 'Splash Screen Unity Logo' to bitmap
å¯¼å‡ºç»§ç»­...
âœ… å¯¼å‡ºæˆåŠŸå®Œæˆ (223/223)
```

---

## ğŸ” æ ¹æœ¬åŸå› åˆ†æ

### ä¸ºä»€ä¹ˆä¼šå‡ºç° 1 å­—èŠ‚çš„çº¹ç†æ•°æ®ï¼Ÿ

å¯èƒ½çš„åŸå› ï¼š
1. **WebGL ç‰¹æ®Šå¤„ç†**: Unity WebGL å¯èƒ½ä½¿ç”¨å ä½ç¬¦çº¹ç†
2. **èµ„æºå‰¥ç¦»**: Splash Screen åœ¨ WebGL æ„å»ºæ—¶å¯èƒ½è¢«ç‰¹æ®Šå¤„ç†
3. **æ•°æ®æŸå**: è§£åŒ…è¿‡ç¨‹ä¸­å¯èƒ½å‡ºç°æ•°æ®æˆªæ–­
4. **Unity Bug**: æŸäº› Unity ç‰ˆæœ¬å¯èƒ½æœ‰åºåˆ—åŒ– bug

### ä¸ºä»€ä¹ˆ `int.Max` æ˜¯é”™è¯¯çš„ï¼Ÿ

```csharp
// å‡è®¾ï¼š
// uncompressedSpan.Length = 1 (æ€»æ•°æ®)
// inputOffset = 0 (å½“å‰ä½ç½®)
// bytesPerLayer = 1048576 (æœŸæœ›çš„å±‚å¤§å°)

// ä½¿ç”¨ int.Maxï¼ˆé”™è¯¯ï¼‰:
int.Max(1 - 0, 1048576) = 1048576
uncompressedSpan.Slice(0, 1048576) // å°è¯•è¯»å– 1MBï¼Œä½†åªæœ‰ 1 å­—èŠ‚ï¼âŒ æŠ›å‡ºå¼‚å¸¸

// ä½¿ç”¨ int.Minï¼ˆæ­£ç¡®ï¼‰:
int.Min(1 - 0, 1048576) = 1
uncompressedSpan.Slice(0, 1) // è¯»å– 1 å­—èŠ‚ âœ… æˆåŠŸï¼ˆè™½ç„¶æ•°æ®ä¸è¶³ï¼Œä½†ä¸ä¼šå´©æºƒï¼‰
```

---

## ğŸ¯ å»ºè®®

### å¯¹äºç”¨æˆ·

1. **æ­£å¸¸ä½¿ç”¨**: ä¿®å¤åçš„ AssetRipper å¯ä»¥æ­£å¸¸å¯¼å‡ºå¤§å¤šæ•°èµ„äº§
2. **æŸåçº¹ç†**: å°‘æ•°æŸåçš„çº¹ç†ä¼šè¢«è·³è¿‡å¹¶è®°å½•è­¦å‘Š
3. **æ£€æŸ¥æ—¥å¿—**: æŸ¥çœ‹æ—¥å¿—æ–‡ä»¶äº†è§£å“ªäº›èµ„äº§è¢«è·³è¿‡

### å¯¹äºå¼€å‘è€…

1. **é˜²å¾¡æ€§ç¼–ç¨‹**: åœ¨æ‰€æœ‰è§£ç å™¨å…¥å£æ·»åŠ æ•°æ®éªŒè¯
2. **æ—©æœŸå¤±è´¥**: åœ¨æ•°æ®æ˜æ˜¾é”™è¯¯æ—¶å°½æ—©è¿”å›ï¼Œé¿å…æ·±å…¥è§£ç 
3. **è¯¦ç»†æ—¥å¿—**: è®°å½•è¶³å¤Ÿçš„ä¸Šä¸‹æ–‡ä¿¡æ¯ä»¥ä¾¿è°ƒè¯•

---

## ğŸ“ ç›¸å…³æ–‡ä»¶

- `AssetRipper/Source/AssetRipper.Export.Modules.Textures/TextureConverter.cs`
- `AssetRipper/Source/AssetRipper.Export.UnityProjects/Textures/TextureAssetExporter.cs`
- `AssetRipper/Source/AssetRipper.Import/AssetCreation/GameAssetFactory.cs` (BuildSettings é”™è¯¯å·²åœ¨æ­¤å¤„æ•è·)

---

## ğŸš€ ä¸‹ä¸€æ­¥

1. âœ… ç¼–è¯‘æˆåŠŸ
2. â­ï¸ æµ‹è¯•ä¿®å¤åçš„ AssetRipper
3. â­ï¸ éªŒè¯çº¹ç†å¯¼å‡ºæ˜¯å¦æ­£å¸¸
4. â­ï¸ ç¡®è®¤ä¸ä¼šå†æœ‰ä¸­æ–­å¯¼å‡ºçš„é”™è¯¯

---

**ä¿®å¤å®Œæˆï¼ç°åœ¨å¯ä»¥é‡æ–°å¯¼å‡ºæ¸¸æˆäº†ï¼** ğŸ‰
